<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="3D Planet Map of Myrdae">
    <title>Planet Myrdae</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700;900&family=Cinzel+Decorative:wght@400;700;900&family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Inter:wght@400;500;600;700&family=Simonetta:ital,wght@0,400;0,900;1,400;1,900&display=swap"
        rel="stylesheet">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Base styles -->
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/dnd-theme.css">

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000814;
            font-family: 'Inter', sans-serif;
        }

        body::before,
        body::after {
            display: none !important;
        }

        #canvas-3d {
            display: block;
            width: 100%;
            height: 100%;
        }

        .map-controls-3d {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }

        .map-btn-3d {
            width: 38px;
            height: 38px;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid var(--color-gold);
            color: var(--color-gold);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .map-btn-3d:hover {
            background: var(--color-gold);
            color: #000;
        }

        .info-panel {
            position: absolute;
            top: 0.75rem;
            left: 0.75rem;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--color-gold);
            border-radius: 8px;
            padding: 1.25rem;
            z-index: 110;
            width: 280px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            max-height: 80vh;
            overflow-y: auto;
        }

        .info-panel h4 {
            margin: 0 0 0.5rem 0;
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--color-gold-bright);
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.5rem;
        }

        .location-name {
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.5rem;
        }

        .location-type {
            font-size: 0.85rem;
            color: var(--color-gold);
            margin-bottom: 0.5rem;
            text-transform: capitalize;
        }

        .location-coords {
            font-size: 0.8rem;
            color: #999;
            font-family: 'Courier New', monospace;
            margin-bottom: 1rem;
        }

        .location-description {
            font-size: 0.9rem;
            color: #ddd;
            line-height: 1.4;
        }

        .info-close {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: var(--color-gold);
            cursor: pointer;
            font-size: 1.5rem;
        }

        .info-close:hover {
            color: #fff;
        }

        .controls-info {
            position: absolute;
            bottom: 0.75rem;
            left: 0.75rem;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid var(--color-gold);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            font-size: 0.8rem;
            color: #ddd;
        }

        .controls-info div {
            margin: 0.25rem 0;
        }

        .controls-info strong {
            color: var(--color-gold);
        }

        .planet-name {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: rgba(255, 215, 0, 0.3);
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>

<body>
    <canvas id="canvas-3d"></canvas>

    <!-- Controls -->
    <div class="map-controls-3d">
        <button class="map-btn-3d" onclick="resetCamera()" title="Reset Camera">
            <i class="fa-solid fa-house"></i>
        </button>
        <button class="map-btn-3d" onclick="toggleLocations()" title="Toggle Location Markers" id="loc-toggle">
            <i class="fa-solid fa-location-dot"></i>
        </button>
    </div>

    <!-- Info Panel (Hidden by default) -->
    <div class="info-panel" id="info-panel" style="display: none;">
        <button class="info-close" onclick="hideInfo()">Ã—</button>
        <div id="info-content"></div>
    </div>

    <!-- Controls Info -->
    <div class="controls-info">
        <div><strong>Mouse:</strong> Drag to rotate, Scroll to zoom</div>
        <div><strong>Click:</strong> Select location</div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="js/locations-db.js"></script>
    <script src="js/campaign-data.js"></script>

    <script>
        console.log("Starting Myrdae 3D Planet...");

        const canvas = document.getElementById('canvas-3d');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000814);
        scene.fog = new THREE.Fog(0x000814, 2000, 5000);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.z = 400;
        
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        
        console.log("Renderer initialized");

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
        sunLight.position.set(200, 150, 200);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1000 * 3);
        for (let i = 0; i < 1000 * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 5000;
            starPositions[i + 1] = (Math.random() - 0.5) * 5000;
            starPositions[i + 2] = (Math.random() - 0.5) * 5000;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 20 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Create Planet with Terrain
        const planetRadius = 180;
        const segments = 64;
        const planetGeometry = new THREE.SphereGeometry(planetRadius, segments, segments);
        
        // Add terrain displacement
        const posArray = planetGeometry.getAttribute('position').array;
        const originalPos = new Float32Array(posArray);
        
        for (let i = 0; i < posArray.length; i += 3) {
            const x = posArray[i];
            const y = posArray[i + 1];
            const z = posArray[i + 2];
            
            const len = Math.sqrt(x * x + y * y + z * z);
            const nx = x / len;
            const ny = y / len;
            const nz = z / len;
            
            // Subtle terrain variation - much smaller displacement
            const noise = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 3 +
                         Math.sin(x * 0.04) * 1.5;
            
            const newRadius = planetRadius + noise;
            
            posArray[i] = nx * newRadius;
            posArray[i + 1] = ny * newRadius;
            posArray[i + 2] = nz * newRadius;
        }
        
        planetGeometry.getAttribute('position').needsUpdate = true;
        planetGeometry.computeVertexNormals();

        // Load planet texture
        const loader = new THREE.TextureLoader();
        let planetMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x5a8c5a,
            roughness: 0.7,
            metalness: 0,
            side: THREE.FrontSide
        });
        
        loader.load('images/Myrdae.jpg', (texture) => {
            console.log("Texture loaded");
            planetMaterial.map = texture;
            planetMaterial.needsUpdate = true;
        }, undefined, (err) => {
            console.log("Texture load failed, using color");
        });
        
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        planet.castShadow = true;
        planet.receiveShadow = true;
        planet.rotation.x = 0.2;
        planet.rotation.z = 0.5;
        scene.add(planet);
        
        console.log("Planet created with terrain variation");

        // Atmosphere
        const atmosphereGeometry = new THREE.SphereGeometry(planetRadius + 8, segments, segments);
        const atmosphereMaterial = new THREE.MeshBasicMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.15,
            side: THREE.BackSide
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Groups for roads and markers (keep as scene children for correct coordinate system)
        const roadsGroup = new THREE.Group();
        const markersGroup = new THREE.Group();
        scene.add(roadsGroup);
        scene.add(markersGroup);
        
        console.log("Groups created and added to scene");
        
        // DEBUG: Create test markers at known positions
        const testPositions = [
            { pos: new THREE.Vector3(0, 150, 0), color: 0xff0000, name: "Top" },
            { pos: new THREE.Vector3(150, 0, 0), color: 0x00ff00, name: "Right" },
            { pos: new THREE.Vector3(0, 0, 150), color: 0x0000ff, name: "Forward" }
        ];
        
        testPositions.forEach(test => {
            const geom = new THREE.SphereGeometry(20, 12, 12);
            const mat = new THREE.MeshStandardMaterial({ 
                color: test.color,
                emissive: test.color,
                emissiveIntensity: 1.0,
                metalness: 0,
                roughness: 0.5
            });
            const marker = new THREE.Mesh(geom, mat);
            marker.position.copy(test.pos);
            markersGroup.add(marker);
            console.log("TEST MARKER:", test.name, "at", test.pos);
        });
        
        console.log("Camera position:", camera.position);
        console.log("Camera looking at origin, markersGroup has", markersGroup.children.length, "children");
        
        let markersVisible = true;

        const typeColors = {
            capital: 0xffffff, city: 0xd4af37, 'small-city': 0xcccccc, town: 0x8b7355,
            village: 0xa0522d, port: 0x87ceeb, ruins: 0x999999, landmark: 0xff8c00,
            nature: 0x228b22, poi: 0xff69b4, region: 0x90ee90, water: 0x4169e1, river: 0x1e90ff
        };

        // Convert map coords to sphere surface
        function coordsToSphere(x, y) {
            const lon = (x / 100) * Math.PI * 2;
            const lat = ((1 - y / 100) * Math.PI) - (Math.PI / 2);
            const r = planetRadius + 18; // Increased offset from surface
            return {
                x: r * Math.cos(lat) * Math.cos(lon),
                y: r * Math.sin(lat),
                z: r * Math.cos(lat) * Math.sin(lon)
            };
        }

        // Create location markers
        function createMarker(location) {
            // Skip regions and other non-marker types
            if (!location.x || !location.y || location.type === 'region') {
                return;
            }
            
            const pos = coordsToSphere(location.x, location.y);
            const color = typeColors[location.type] || 0x888888;
            
            // Visible glowing sphere using MeshStandardMaterial
            const markerGeom = new THREE.SphereGeometry(15, 12, 12);
            const markerMat = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: color,
                emissiveIntensity: 0.8,
                metalness: 0.2,
                roughness: 0.4,
                toneMapped: false
            });
            const marker = new THREE.Mesh(markerGeom, markerMat);
            marker.position.set(pos.x, pos.y, pos.z);
            marker.userData = location;
            markersGroup.add(marker);
        }

        // Create roads
        function createRoad(start, end, isMajor) {
            const startPos = coordsToSphere(start.x, start.y);
            const endPos = coordsToSphere(end.x, end.y);
            
            const curve = new THREE.LineCurve3(
                new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                new THREE.Vector3(endPos.x, endPos.y, endPos.z)
            );
            
            const points = curve.getPoints(30);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: isMajor ? 0xd4af37 : 0x8b7355,
                linewidth: isMajor ? 8 : 5,
                fog: false,
                toneMapped: false
            });
            
            const line = new THREE.Line(geometry, material);
            roadsGroup.add(line);
        }

        // Mouse controls
        let isDragging = false;
        let prevX = 0, prevY = 0;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            prevX = e.clientX;
            prevY = e.clientY;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - prevX;
            const dy = e.clientY - prevY;
            planet.rotation.y += dx * 0.008;
            planet.rotation.x += dy * 0.008;
            atmosphere.rotation.copy(planet.rotation);
            prevX = e.clientX;
            prevY = e.clientY;
        });

        document.addEventListener('mouseup', () => { isDragging = false; });

        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.2;
            camera.position.z = Math.max(200, Math.min(800, camera.position.z));
        });

        // Click detection for markers
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        document.addEventListener('click', (e) => {
            if (isDragging) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(markersGroup.children);
            
            if (hits.length > 0) {
                const location = hits[0].object.userData;
                const panel = document.getElementById('info-panel');
                const content = document.getElementById('info-content');
                
                content.innerHTML = `
                    <h4><i class="fa-solid fa-location-dot"></i> ${location.name}</h4>
                    <p><strong>Type:</strong> <span class="location-type">${location.type}</span></p>
                    <p><strong>Coordinates:</strong> X: ${location.x.toFixed(1)}, Y: ${location.y.toFixed(1)}</p>
                    ${location.region ? `<p><strong>Region:</strong> ${location.region}</p>` : ''}
                    ${location.description ? `<p>${location.description}</p>` : ''}
                `;
                
                panel.style.display = 'block';
            }
        });

        function resetCamera() {
            camera.position.z = 400;
            planet.rotation.set(0.2, 0, 0.5);
            atmosphere.rotation.copy(planet.rotation);
            markersGroup.rotation.copy(planet.rotation);
            roadsGroup.rotation.copy(planet.rotation);
        }

        function toggleLocations() {
            markersVisible = !markersVisible;
            markersGroup.visible = markersVisible;
            roadsGroup.visible = markersVisible;
            document.getElementById('loc-toggle').style.opacity = markersVisible ? '1' : '0.5';
        }

        function hideInfo() {
            document.getElementById('info-panel').style.display = 'none';
        }

        // Initialize with data
        async function init() {
            console.log("Loading campaign data...");
            await CampaignData.init();
            
            const locations = CampaignData.getLocations();
            console.log("Loaded", locations.length, "total locations");
            
            // Analyze location distribution
            const validLocations = locations.filter(l => l.x !== undefined && l.y !== undefined && l.type !== 'region');
            console.log("Valid markers (excluding regions):", validLocations.length);
            
            if (validLocations.length > 0) {
                const xValues = validLocations.map(l => l.x);
                const yValues = validLocations.map(l => l.y);
                console.log("X range:", Math.min(...xValues), "to", Math.max(...xValues));
                console.log("Y range:", Math.min(...yValues), "to", Math.max(...yValues));
                console.log("First 5 locations:", validLocations.slice(0, 5).map(l => ({ name: l.name, x: l.x, y: l.y, type: l.type })));
            }
            
            if (locations.length > 0) {
                locations.forEach((loc) => {
                    createMarker(loc);
                });
            }
            
            // Draw roads if available
            const roads = CampaignData.getRoads();
            if (roads && roads.length > 0) {
                console.log("Creating", roads.length, "roads");
                roads.forEach((route, idx) => {
                    if (route.points && route.points.length >= 3) {
                        // Roads are stored as: [startLocationId, [x,y], [x,y], ..., endLocationId]
                        for (let i = 1; i < route.points.length - 1; i++) {
                            const curr = route.points[i];
                            const next = route.points[i + 1];
                            if (Array.isArray(curr) && Array.isArray(next)) {
                                const start = { x: curr[0], y: curr[1] };
                                const end = { x: next[0], y: next[1] };
                                createRoad(start, end, route.type === 'major');
                            }
                        }
                        if (idx === 0) console.log("Sample road created from route");
                    }
                });
            } else {
                console.log("No roads found in campaign data");
            }
            
            console.log("Markers group children:", markersGroup.children.length);
            console.log("Roads group children:", roadsGroup.children.length);
            console.log("Initialization complete, starting animation");
            animate();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto-rotate when not dragging
            if (!isDragging) {
                planet.rotation.y += 0.0002;
                atmosphere.rotation.y += 0.0002;
            }
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start everything
        init().catch(err => {
            console.error("Initialization error:", err);
            animate();
        });
    </script>
</body>

</html>
