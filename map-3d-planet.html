<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="3D Planet Map of Myrdae">
    <title>Planet Myrdae</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700;900&family=Cinzel+Decorative:wght@400;700;900&family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Inter:wght@400;500;600;700&family=Simonetta:ital,wght@0,400;0,900;1,400;1,900&display=swap"
        rel="stylesheet">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Base styles -->
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/dnd-theme.css">

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000510;
            font-family: 'Inter', sans-serif;
        }

        body::before,
        body::after {
            display: none !important;
        }

        #canvas-3d {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Loading screen */
        #loading-screen {
            position: absolute;
            inset: 0;
            background: #000510;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
            transition: opacity 0.8s ease;
        }

        #loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #loading-screen h1 {
            font-family: 'Cinzel Decorative', serif;
            font-size: 2.5rem;
            color: #d4af37;
            margin: 0 0 1.5rem 0;
            letter-spacing: 0.1em;
            text-shadow: 0 0 40px rgba(212, 175, 55, 0.4);
        }

        #loading-screen p {
            color: rgba(212, 175, 55, 0.5);
            font-family: 'Cinzel', serif;
            font-size: 0.8rem;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            animation: loadingPulse 1.6s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.4; }
            50%       { opacity: 1; }
        }

        .map-controls-3d {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }

        .map-btn-3d {
            width: 38px;
            height: 38px;
            background: rgba(5, 8, 18, 0.88);
            border: 1px solid var(--color-gold);
            color: var(--color-gold);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .map-btn-3d:hover {
            background: var(--color-gold);
            color: #000;
        }

        .info-panel {
            position: absolute;
            top: 0.75rem;
            left: 0.75rem;
            background: rgba(5, 8, 18, 0.96);
            border: 1px solid var(--color-gold);
            border-radius: 8px;
            padding: 1.25rem;
            z-index: 110;
            width: 280px;
            pointer-events: auto;
            backdrop-filter: blur(12px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), 0 0 40px rgba(212, 175, 55, 0.05);
            max-height: 80vh;
            overflow-y: auto;
        }

        .info-panel h4 {
            margin: 0 0 0.5rem 0;
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--color-gold-bright);
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.5rem;
        }

        .info-panel p {
            margin: 0.35rem 0;
            font-size: 0.875rem;
            color: #ccc;
            line-height: 1.45;
        }

        .info-panel p strong {
            color: var(--color-gold);
        }

        .location-type {
            font-size: 0.85rem;
            color: var(--color-gold);
            text-transform: capitalize;
        }

        .info-close {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: var(--color-gold);
            cursor: pointer;
            font-size: 1.5rem;
            line-height: 1;
        }

        .info-close:hover {
            color: #fff;
        }

        .controls-info {
            position: absolute;
            bottom: 0.75rem;
            left: 0.75rem;
            background: rgba(5, 8, 18, 0.85);
            border: 1px solid rgba(212, 175, 55, 0.25);
            border-radius: 6px;
            padding: 0.6rem 0.9rem;
            font-size: 0.75rem;
            color: #aaa;
        }

        .controls-info div {
            margin: 0.2rem 0;
        }

        .controls-info strong {
            color: var(--color-gold);
        }

        /* Hover tooltip */
        #hover-tooltip {
            position: absolute;
            background: rgba(5, 8, 18, 0.93);
            border: 1px solid rgba(212, 175, 55, 0.55);
            border-radius: 4px;
            padding: 0.3rem 0.65rem;
            pointer-events: none;
            z-index: 200;
            display: none;
            white-space: nowrap;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.65);
        }

        #hover-tooltip .tt-name {
            font-family: 'Cinzel', serif;
            font-size: 0.8rem;
            color: #fff;
        }

        #hover-tooltip .tt-type {
            font-size: 0.68rem;
            color: var(--color-gold);
            text-transform: capitalize;
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>

<body>
    <!-- Loading screen -->
    <div id="loading-screen">
        <h1>Myrdae</h1>
        <p>Charting the Realm&hellip;</p>
    </div>

    <canvas id="canvas-3d"></canvas>

    <!-- Hover tooltip -->
    <div id="hover-tooltip">
        <div class="tt-name" id="tt-name"></div>
        <div class="tt-type" id="tt-type"></div>
    </div>

    <!-- Controls -->
    <div class="map-controls-3d">
        <button class="map-btn-3d" onclick="resetCamera()" title="Reset Camera">
            <i class="fa-solid fa-house"></i>
        </button>
        <button class="map-btn-3d" onclick="toggleLocations()" title="Toggle Location Markers" id="loc-toggle">
            <i class="fa-solid fa-location-dot"></i>
        </button>
    </div>

    <!-- Info Panel (Hidden by default) -->
    <div class="info-panel" id="info-panel" style="display: none;">
        <button class="info-close" onclick="hideInfo()">×</button>
        <div id="info-content"></div>
    </div>

    <!-- Controls Info -->
    <div class="controls-info">
        <div><strong>Drag:</strong> Rotate globe</div>
        <div><strong>Scroll:</strong> Zoom in / out</div>
        <div><strong>Click:</strong> View location details</div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="js/locations-db.js"></script>
    <script src="js/campaign-data.js"></script>

    <script>
        // ── Scene setup ────────────────────────────────────────────────────────────
        const canvas = document.getElementById('canvas-3d');
        const scene  = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog        = new THREE.Fog(0x000510, 2000, 5000);

        // Tighter FOV gives a more "globe" look vs the wide-angle distortion of 75°
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.z = 420;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type    = THREE.PCFSoftShadowMap;

        // ── Lighting ───────────────────────────────────────────────────────────────
        // Blue-tinted ambient keeps the dark side from going pure black
        const ambientLight = new THREE.AmbientLight(0x2a3a5a, 1.0);
        scene.add(ambientLight);

        // Warm directional "sun"
        const sunLight = new THREE.DirectionalLight(0xfff5d0, 1.4);
        sunLight.position.set(300, 200, 300);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width  = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Faint cool fill from the opposite side — separates the dark limb from pure black
        const fillLight = new THREE.DirectionalLight(0x1a2a6a, 0.22);
        fillLight.position.set(-300, -100, -300);
        scene.add(fillLight);

        // ── Starfield ──────────────────────────────────────────────────────────────
        // Stars are placed on a sphere shell (min 2500 units from origin) so they are
        // always further away than the planet and can never overlap it.
        // A circular canvas texture stops PointsMaterial rendering squares.
        (function buildStarfield() {
            // Circular soft-dot texture — makes points round instead of square
            const starCanvas = document.createElement('canvas');
            starCanvas.width = starCanvas.height = 32;
            const sCtx = starCanvas.getContext('2d');
            const grad = sCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0,   'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.6)');
            grad.addColorStop(1,   'rgba(255,255,255,0)');
            sCtx.fillStyle = grad;
            sCtx.fillRect(0, 0, 32, 32);
            const starTex = new THREE.CanvasTexture(starCanvas);

            const COUNT     = 8000;
            const positions = new Float32Array(COUNT * 3);
            const colors    = new Float32Array(COUNT * 3);

            for (let i = 0; i < COUNT; i++) {
                // Uniform distribution on a sphere shell between 2500–4500 units
                const theta = Math.random() * Math.PI * 2;
                const phi   = Math.acos(2 * Math.random() - 1);
                const r     = 2500 + Math.random() * 2000;
                positions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);

                const rng = Math.random();
                if (rng < 0.07) {
                    colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.88; colors[i * 3 + 2] = 0.6;
                } else if (rng < 0.14) {
                    colors[i * 3] = 0.7; colors[i * 3 + 1] = 0.85; colors[i * 3 + 2] = 1.0;
                } else {
                    const v = 0.6 + Math.random() * 0.4;
                    colors[i * 3] = v; colors[i * 3 + 1] = v; colors[i * 3 + 2] = v;
                }
            }

            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geom.setAttribute('color',    new THREE.BufferAttribute(colors,    3));
            const starPoints = new THREE.Points(geom, new THREE.PointsMaterial({
                size: 2.5,
                sizeAttenuation: false,
                vertexColors: true,
                map: starTex,
                transparent: true,
                alphaTest: 0.01,
                depthWrite: false,  // stars never write depth — planet always renders on top
            }));
            starPoints.renderOrder = -1;
            scene.add(starPoints);

            // A handful of brighter feature stars
            const bCount     = 60;
            const bPositions = new Float32Array(bCount * 3);
            for (let i = 0; i < bCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi   = Math.acos(2 * Math.random() - 1);
                const r     = 2600 + Math.random() * 1800;
                bPositions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
                bPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                bPositions[i * 3 + 2] = r * Math.cos(phi);
            }
            const bGeom = new THREE.BufferGeometry();
            bGeom.setAttribute('position', new THREE.BufferAttribute(bPositions, 3));
            const brightPoints = new THREE.Points(bGeom, new THREE.PointsMaterial({
                size: 4,
                sizeAttenuation: false,
                color: 0xffffff,
                map: starTex,
                transparent: true,
                alphaTest: 0.01,
                depthWrite: false,
            }));
            brightPoints.renderOrder = -1;
            scene.add(brightPoints);
        })();

        // ── Planet ─────────────────────────────────────────────────────────────────
        const planetRadius = 180;
        const segments     = 64;
        const planetGeometry = new THREE.SphereGeometry(planetRadius, segments, segments);

        // Subtle terrain displacement
        const posArray = planetGeometry.getAttribute('position').array;
        for (let i = 0; i < posArray.length; i += 3) {
            const x = posArray[i], y = posArray[i + 1], z = posArray[i + 2];
            const len = Math.sqrt(x * x + y * y + z * z);
            const nx = x / len, ny = y / len, nz = z / len;
            const noise = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 3 + Math.sin(x * 0.04) * 1.5;
            const r = planetRadius + noise;
            posArray[i] = nx * r; posArray[i + 1] = ny * r; posArray[i + 2] = nz * r;
        }
        planetGeometry.getAttribute('position').needsUpdate = true;
        planetGeometry.computeVertexNormals();

        const loader = new THREE.TextureLoader();
        const planetMaterial = new THREE.MeshStandardMaterial({
            color: 0x5a8c5a,
            roughness: 0.75,
            metalness: 0.0,
        });

        loader.load('images/Myrdae.jpg', (texture) => {
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            planetMaterial.map = texture;
            planetMaterial.needsUpdate = true;
        }, undefined, () => {
            console.log("Texture load failed — using base color");
        });

        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        planet.castShadow    = true;
        planet.receiveShadow = true;
        scene.add(planet);

        // ── Atmosphere ─────────────────────────────────────────────────────────────
        // Two BackSide layers: inner haze + wide outer rim glow.
        // BackSide trick: the shell is only visible at the planet's limb, creating a
        // natural-looking atmospheric halo without needing a custom shader.
        const atmosphere = new THREE.Mesh(
            new THREE.SphereGeometry(planetRadius + 7, segments, segments),
            new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.13, side: THREE.BackSide })
        );
        scene.add(atmosphere);

        const outerGlow = new THREE.Mesh(
            new THREE.SphereGeometry(planetRadius + 28, segments, segments),
            new THREE.MeshBasicMaterial({ color: 0x1a3a9a, transparent: true, opacity: 0.07, side: THREE.BackSide })
        );
        scene.add(outerGlow);

        // ── Groups ─────────────────────────────────────────────────────────────────
        const roadsGroup   = new THREE.Group();
        const markersGroup = new THREE.Group();
        scene.add(roadsGroup);
        scene.add(markersGroup);

        // Initial rotation — THREE.js SphereGeometry UV maps u=0 → (-x face), so
        // coordsToSphere uses -x to match. Continent center is at map x≈64.3 (lon≈4.04 rad),
        // which sits at 3D pos (0.69, 0, -0.72). rotation.y=3.91 brings it front-facing.
        const INIT_ROT_X = 0.15;
        const INIT_ROT_Y = 3.91;
        planet.rotation.set(INIT_ROT_X, INIT_ROT_Y, 0);
        syncGroups();

        let markersVisible = true;

        // ── Location config ────────────────────────────────────────────────────────
        const typeColors = {
            capital: 0xffffff, city: 0xd4af37, 'small-city': 0xe0e0e0, town: 0xb09070,
            village: 0xa0784d, port: 0x87ceeb, ruins: 0x999999, landmark: 0xff8c00,
            nature: 0x40b840, poi: 0xff69b4, region: 0x90ee90, water: 0x4169e1, river: 0x1e90ff,
        };

        // Marker radius by settlement importance — capitals are visibly larger than villages
        const typeSizes = {
            capital: 6.5, city: 5.5, 'small-city': 4.5, town: 3.5,
            village: 2.5, port: 4.0, ruins: 3.0, landmark: 3.5,
            nature: 2.5, poi: 3.0, region: 0, water: 0, river: 0,
        };

        // ── Coordinate mapping ─────────────────────────────────────────────────────
        // THREE.js SphereGeometry formula: x = -cos(phi)*sin(theta), z = sin(phi)*sin(theta)
        // So u=0 → (-1,0,0). Our lon=0 (map x=0) must also map to (-1,0,0) — hence the -x.
        function coordsToSphere(x, y, offset = 2) {
            const lon = (x / 100) * Math.PI * 2;
            const lat = ((1 - y / 100) * Math.PI) - (Math.PI / 2);
            const r   = planetRadius + offset;
            return new THREE.Vector3(
                -r * Math.cos(lat) * Math.cos(lon),   // negative x to match THREE.js UV convention
                 r * Math.sin(lat),
                 r * Math.cos(lat) * Math.sin(lon)
            );
        }

        // ── Markers ────────────────────────────────────────────────────────────────
        function createMarker(location) {
            if (!location.x || !location.y || location.type === 'region') return;
            const size = typeSizes[location.type] ?? 2.5;
            if (size === 0) return;

            const color  = typeColors[location.type] || 0x888888;
            const pos    = coordsToSphere(location.x, location.y);

            const marker = new THREE.Mesh(
                new THREE.SphereGeometry(size, 8, 8),
                new THREE.MeshStandardMaterial({
                    color,
                    emissive: color,
                    emissiveIntensity: 0.85,
                    metalness: 0.1,
                    roughness: 0.2,
                    toneMapped: false,
                })
            );
            marker.position.copy(pos);
            marker.userData = location;
            markersGroup.add(marker);
        }

        // ── Roads ──────────────────────────────────────────────────────────────────
        // Fix: straight LineCurve3 cut through the globe. Great-circle arcs via
        // lerp + normalize keep every point on the sphere surface.
        function createRoad(start, end, isMajor) {
            const sv = coordsToSphere(start.x, start.y, 0).normalize();
            const ev = coordsToSphere(end.x,   end.y,   0).normalize();

            const STEPS  = 24;
            const points = [];
            for (let i = 0; i <= STEPS; i++) {
                const p = new THREE.Vector3()
                    .lerpVectors(sv, ev, i / STEPS)
                    .normalize()
                    .multiplyScalar(planetRadius + 2);
                points.push(p);
            }

            const geom = new THREE.BufferGeometry().setFromPoints(points);
            const mat  = new THREE.LineBasicMaterial({
                color: isMajor ? 0xd4af37 : 0x8b7355,
                linewidth: 1,
                fog: false,
                toneMapped: false,
            });
            roadsGroup.add(new THREE.Line(geom, mat));
        }

        // ── Mouse controls ─────────────────────────────────────────────────────────
        let isDragging = false;
        let hasDragged = false;   // Fix: mouseup clears isDragging before click fires
        let prevX = 0, prevY = 0;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            hasDragged = false;
            prevX = e.clientX;
            prevY = e.clientY;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - prevX;
                const dy = e.clientY - prevY;
                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) hasDragged = true;
                planet.rotation.y += dx * 0.007;
                planet.rotation.x += dy * 0.007;
                syncGroups();
                prevX = e.clientX;
                prevY = e.clientY;
                hideTooltip();
                return;
            }
            updateTooltip(e);
        });

        document.addEventListener('mouseup', () => { isDragging = false; });

        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.2;
            camera.position.z = Math.max(210, Math.min(900, camera.position.z));
        }, { passive: false });

        // ── Raycasting & tooltip ───────────────────────────────────────────────────
        const raycaster = new THREE.Raycaster();
        const mouse     = new THREE.Vector2();
        const tooltip   = document.getElementById('hover-tooltip');

        function updateTooltip(e) {
            mouse.x = (e.clientX / window.innerWidth)  *  2 - 1;
            mouse.y = (e.clientY / window.innerHeight) * -2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(markersGroup.children);

            if (hits.length > 0) {
                const loc = hits[0].object.userData;
                document.getElementById('tt-name').textContent = loc.name;
                document.getElementById('tt-type').textContent = loc.type;
                tooltip.style.left    = (e.clientX + 14) + 'px';
                tooltip.style.top     = (e.clientY - 10) + 'px';
                tooltip.style.display = 'block';
                document.body.style.cursor = 'pointer';
            } else {
                hideTooltip();
            }
        }

        function hideTooltip() {
            tooltip.style.display      = 'none';
            document.body.style.cursor = '';
        }

        document.addEventListener('click', (e) => {
            if (hasDragged) return;   // Don't treat a drag-release as a click

            mouse.x = (e.clientX / window.innerWidth)  *  2 - 1;
            mouse.y = (e.clientY / window.innerHeight) * -2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(markersGroup.children);

            if (hits.length > 0) {
                const loc     = hits[0].object.userData;
                const content = document.getElementById('info-content');
                content.innerHTML = `
                    <h4><i class="fa-solid fa-location-dot"></i> ${loc.name}</h4>
                    <p><strong>Type:</strong> <span class="location-type">${loc.type}</span></p>
                    <p><strong>Coordinates:</strong> X: ${loc.x.toFixed(1)}, Y: ${loc.y.toFixed(1)}</p>
                    ${loc.region      ? `<p><strong>Region:</strong> ${loc.region}</p>` : ''}
                    ${loc.description ? `<p>${loc.description}</p>` : ''}
                `;
                document.getElementById('info-panel').style.display = 'block';
            }
        });

        // ── Helpers ────────────────────────────────────────────────────────────────
        function syncGroups() {
            atmosphere.rotation.copy(planet.rotation);
            outerGlow.rotation.copy(planet.rotation);
            markersGroup.rotation.copy(planet.rotation);
            roadsGroup.rotation.copy(planet.rotation);
        }

        function resetCamera() {
            camera.position.z = 420;
            planet.rotation.set(INIT_ROT_X, INIT_ROT_Y, 0);
            syncGroups();
        }

        function toggleLocations() {
            markersVisible = !markersVisible;
            markersGroup.visible = markersVisible;
            roadsGroup.visible   = markersVisible;
            document.getElementById('loc-toggle').style.opacity = markersVisible ? '1' : '0.5';
        }

        function hideInfo() {
            document.getElementById('info-panel').style.display = 'none';
        }

        // ── Init ───────────────────────────────────────────────────────────────────
        async function init() {
            await CampaignData.init();

            const locations = CampaignData.getLocations();
            locations.forEach(createMarker);
            console.log('Markers:', markersGroup.children.length);

            const roads = CampaignData.getRoads();
            if (roads && roads.length > 0) {
                roads.forEach((route) => {
                    if (!route.points || route.points.length < 3) return;
                    for (let i = 1; i < route.points.length - 1; i++) {
                        const curr = route.points[i];
                        const next = route.points[i + 1];
                        if (Array.isArray(curr) && Array.isArray(next)) {
                            createRoad({ x: curr[0], y: curr[1] }, { x: next[0], y: next[1] }, route.type === 'major');
                        }
                    }
                });
                console.log('Roads:', roadsGroup.children.length);
            }

            // Fade out loading screen once data is ready
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.classList.add('fade-out');
            setTimeout(() => { loadingScreen.style.display = 'none'; }, 900);

            animate();
        }

        // ── Animation loop ─────────────────────────────────────────────────────────
        function animate() {
            requestAnimationFrame(animate);

            if (!isDragging) {
                planet.rotation.y += 0.0002;
            }

            // Always keep groups in sync with current planet rotation
            syncGroups();

            renderer.render(scene, camera);
        }

        // ── Resize ─────────────────────────────────────────────────────────────────
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init().catch((err) => {
            console.error('Init error:', err);
            document.getElementById('loading-screen').style.display = 'none';
            animate();
        });
    </script>
</body>

</html>
